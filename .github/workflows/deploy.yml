name: Deploy

on:
  # 手动触发
  workflow_dispatch:
  # push:
  #   branches: [main]
  #   paths:
  #     - src/**
  #     - public/**
  #     - scripts/**
  #     - next.config.js
  #     - package.json
  #     - pnpm-lock.yaml
  # pull_request:
  #   branches: [main]
  #   paths:
  #     - src/**
  #     - public/**
  #     - scripts/**
  #     - next.config.js
  #     - package.json
  #     - pnpm-lock.yaml

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      # 切换分支
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      # 生成版本号（基于时间）
      - name: Generate version
        id: version
        run: |
          VERSION=$(date +%Y%m%d%H%M%S)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

      - uses: pnpm/action-setup@v4
        name: Install pnpm
        with:
          version: 10
          run_install: false

      # 使用 node:lts/jod
      - name: use Node.js lts/jod
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/jod'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm i

      # build
      - name: Build
        run: pnpm run publish-t1

      # tar
      - name: Tar dist
        run: tar zcf build.tar.gz --exclude=build/cache build public scripts package.json pnpm-lock.yaml .npmrc next.config.js Dockerfile docker-compose.yaml

      # Deploy to server
      - name: Deploy to server
        id: deploy
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.REMOTE_PREVIEW_HOST }}
          username: ${{ secrets.REMOTE_PREVIEW_USER }}
          key: ${{ secrets.ACCESS_TOKEN }}
          source: 'build.tar.gz'
          target: /web/next

      # 零停机部署
      - name: Zero-downtime deployment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.REMOTE_PREVIEW_HOST }}
          username: ${{ secrets.REMOTE_PREVIEW_USER }}
          key: ${{ secrets.ACCESS_TOKEN }}
          script: |
            # 进入工作目录
            cd /web/next
            echo "Working directory: $(pwd)"

            # 解压新版本文件
            echo "Extracting new build..."
            tar zxf build.tar.gz
            rm build.tar.gz

            # =====================================================
            # 配置变量集中定义区域
            # =====================================================

            # 基础配置
            IMAGE_NAME="next"
            VERSION=$(date +%Y%m%d%H%M%S)

            # 镜像标签定义
            NEW_IMAGE_TAG="${IMAGE_NAME}:${VERSION}"
            CURRENT_IMAGE_TAG="${IMAGE_NAME}:current"
            PREVIOUS_IMAGE_TAG="${IMAGE_NAME}:previous"

            # 备份文件定义（时间戳命名 - 部署成功后备份策略）
            # 格式: build-backup-YYYYMMDDHHMMSS.tar.gz
            # 策略: 只备份部署成功的版本，保留最近2份
            BACKUP_TIMESTAMP=$(date +%Y%m%d%H%M%S)
            VERSION_BACKUP="build-backup-${BACKUP_TIMESTAMP}.tar.gz"

            # 健康检查配置
            MAX_RETRIES=10
            RETRY_DELAY=3
            HEALTH_CHECK_URL="http://localhost:8000/api/health"
            HEALTH_CHECK_PASSED=false

            # =====================================================
            # 输出配置信息 - 增强版本
            # =====================================================
            echo "🚀 Starting Deployment..."
            echo "Deploying version: $VERSION"
            echo "Environment: PRODUCTION"
            echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"
            echo ""
            echo "📋 Configuration Details:"
            echo "  APP_NAME: $APP_NAME"
            echo "  VERSION: $VERSION"
            echo "  NEW_IMAGE_TAG: $NEW_IMAGE_TAG"
            echo "  CURRENT_IMAGE_TAG: $CURRENT_IMAGE_TAG"
            echo "  PREVIOUS_IMAGE_TAG: $PREVIOUS_IMAGE_TAG"
            echo "  VERSION_BACKUP: $VERSION_BACKUP"
            echo "  HEALTH_CHECK_URL: $HEALTH_CHECK_URL"
            echo "  MAX_RETRIES: $MAX_RETRIES"
            echo "  RETRY_DELAY: ${RETRY_DELAY}s"
            echo ""

            # =====================================================
            # 解压新版本（保留build.tar.gz用于后续备份）
            # =====================================================
            echo "📂 Extraction Phase:"
            echo "  📦 Extracting new build..."
            tar zxf build.tar.gz
            echo "  ✓ New version extracted successfully (build.tar.gz preserved for backup)."
            echo ""

            # =====================================================
            # 健康检查函数定义 - 模块化升级版本
            # =====================================================

            # 健康检查函数
            perform_health_check() {
                local url="$1"
                local max_retries="${2:-$MAX_RETRIES}"
                local retry_delay="${3:-$RETRY_DELAY}"

                echo "🏥 Performing health check at: $url"

                for i in $(seq 1 $max_retries); do
                    echo "  📊 Attempt $i/$max_retries: Checking health at $url..."
                    if curl --fail --silent --show-error --connect-timeout 5 --max-time 10 "$url"; then
                        echo "  ✅ Health check passed!"
                        return 0
                    fi
                    if [ $i -lt $max_retries ]; then
                        echo "  ⏳ Health check failed. Retrying in $retry_delay seconds..."
                        sleep $retry_delay
                    else
                        echo "  ❌ Health check failed after $max_retries attempts."
                    fi
                done

                echo "  💥 Health check failed completely."
                return 1
            }

            # =====================================================
            # Docker 镜像构建阶段
            # =====================================================

            echo "🐳 Docker Build Phase:"
            echo "  🔨 Building new image: $NEW_IMAGE_TAG"
            docker build -t "$NEW_IMAGE_TAG" .
            echo "  ✅ Image built successfully."
            echo ""

            # =====================================================
            # Docker 零停机部署函数定义
            # =====================================================

            # Docker 镜像版本管理函数
            manage_docker_images() {
                echo "🏷️ Docker Image Management Phase:"

                # 检查当前是否有运行的容器
                local current_container=$(docker ps -q --filter "name=${APP_NAME}")

                if [ ! -z "$current_container" ]; then
                    echo "  🔍 Found running container: $current_container"

                    # 备份当前镜像标签
                    local current_image=$(docker inspect --format='{{.Config.Image}}' $current_container 2>/dev/null || echo "")
                    if [ ! -z "$current_image" ] && [ "$current_image" != "$NEW_IMAGE_TAG" ]; then
                        echo "  📦 Backing up current image as previous:"
                        echo "    $current_image → $PREVIOUS_IMAGE_TAG"
                        docker tag "$current_image" "$PREVIOUS_IMAGE_TAG" 2>/dev/null || true
                        echo "  ✅ Image backup completed."
                    else
                        echo "  ℹ️  No image backup needed."
                    fi
                else
                    echo "  ℹ️  No running container found (first deployment)."
                fi

                # 标记新镜像为当前版本
                echo "  🏷️ Tagging new image as current version..."
                docker tag "$NEW_IMAGE_TAG" "$CURRENT_IMAGE_TAG"
                echo "  ✅ Image tagging completed."
                echo ""
            }

            # Docker Compose 配置更新函数
            update_docker_compose() {
                echo "📝 Docker Compose Configuration Update:"
                echo "  📋 Before update - Current image line:"
                grep "image:" docker-compose.yaml | head -1

                echo "  🔧 Updating docker-compose.yaml with new image: $CURRENT_IMAGE_TAG"
                sed -i "s|image: [^[:space:]#]*|image: ${CURRENT_IMAGE_TAG}|" docker-compose.yaml

                echo "  📋 After update - New image line:"
                grep "image:" docker-compose.yaml | head -1
                echo "  ✅ Configuration update completed."
                echo ""
            }

            # Docker 零停机部署函数
            deploy_with_docker() {
                echo "🚀 Docker Zero-Downtime Deployment Phase:"
                echo "  🔄 Starting zero-downtime deployment..."

                # 重新创建并启动容器（这会先启动新容器，再停止旧容器）
                if docker compose up -d --force-recreate --remove-orphans; then
                    echo "  ✅ Docker Compose deployment successful!"

                    # 等待新容器启动
                    echo "  ⏳ Waiting for new container to fully start..."
                    sleep 10
                    echo "  ✅ Container startup completed."
                    return 0
                else
                    echo "  ❌ Docker Compose deployment failed!"
                    return 1
                fi
            }

            # =====================================================
            # 执行 Docker 部署流程
            # =====================================================

            # 执行镜像管理
            manage_docker_images

            # 更新配置文件
            update_docker_compose

            # 执行零停机部署
            if ! deploy_with_docker; then
                echo "💥 Docker deployment failed! Will attempt rollback later."
                DOCKER_DEPLOY_FAILED=true
            else
                echo "🎉 Docker deployment phase completed successfully!"
                DOCKER_DEPLOY_FAILED=false
            fi
            echo ""

            # =====================================================
            # 自动回退机制函数定义
            # =====================================================

            # Docker 镜像级回退函数
            rollback_docker_image() {
                echo "🔄 Docker Image Rollback Phase:"

                # 检查是否有之前的镜像可以回滚
                if docker image inspect "$PREVIOUS_IMAGE_TAG" >/dev/null 2>&1; then
                    echo "  📦 Rolling back to previous Docker image: $PREVIOUS_IMAGE_TAG"

                    # 更新 docker-compose.yaml 使用之前的镜像
                    sed -i "s|image: [^[:space:]#]*|image: ${PREVIOUS_IMAGE_TAG}|" docker-compose.yaml

                    # 重新启动服务
                    echo "  🔄 Restarting services with previous image..."
                    docker compose down --remove-orphans || true
                    docker compose up -d

                    # 等待回滚完成
                    echo "  ⏳ Waiting for rollback to complete..."
                    sleep 10

                    return 0
                else
                    echo "  ❌ No previous Docker image available for rollback!"
                    return 1
                fi
            }

            # 文件级回退函数（增强版本）
            rollback_build_files() {
                echo "📁 File-Level Rollback Phase:"

                # 查找最新的备份文件
                LATEST_BACKUP=$(ls -t build-backup-*.tar.gz 2>/dev/null | head -1)

                if [ -n "$LATEST_BACKUP" ] && [ -f "$LATEST_BACKUP" ]; then
                    echo "  📦 Rolling back to latest backup: $LATEST_BACKUP"

                    # 恢复备份版本
                    echo "  🔄 Restoring backup files..."
                    rm -rf build 2>/dev/null || true
                    tar zxf "$LATEST_BACKUP"
                    echo "  ✅ Backup files restored."

                    # 重建镜像
                    echo "  🔨 Rebuilding image from backup..."
                    local backup_image_tag="${APP_NAME}:backup-$(date +%Y%m%d%H%M%S)"
                    docker build -t "$backup_image_tag" .
                    docker tag "$backup_image_tag" "$CURRENT_IMAGE_TAG"

                    # 更新配置并重启
                    sed -i "s|image: [^[:space:]#]*|image: ${CURRENT_IMAGE_TAG}|" docker-compose.yaml
                    docker compose down --remove-orphans || true
                    docker compose up -d

                    echo "  ⏳ Waiting for file rollback to complete..."
                    sleep 10

                    return 0
                else
                    echo "  ❌ No backup files available for rollback!"
                    return 1
                fi
            }

            # 完整回退函数（双层回退策略）
            perform_complete_rollback() {
                echo "🆘 Complete Rollback Process Starting..."

                # 第一层：尝试 Docker 镜像回退
                if rollback_docker_image; then
                    echo "  ✅ Docker image rollback completed."

                    # 验证 Docker 镜像回退结果
                    echo "  🏥 Verifying Docker rollback with health check..."
                    if perform_health_check "$HEALTH_CHECK_URL"; then
                        echo "  🎉 Docker rollback successful! Service is healthy."
                        return 0
                    else
                        echo "  ⚠️ Docker rollback verification failed, trying file-level rollback..."
                    fi
                fi

                # 第二层：尝试文件级回退
                if rollback_build_files; then
                    echo "  ✅ File-level rollback completed."

                    # 验证文件级回退结果
                    echo "  🏥 Verifying file rollback with health check..."
                    if perform_health_check "$HEALTH_CHECK_URL"; then
                        echo "  🎉 File rollback successful! Service is healthy."
                        return 0
                    else
                        echo "  💥 File rollback verification failed!"
                    fi
                else
                    echo "  💥 File-level rollback failed!"
                fi

                echo "  🚨 Complete rollback failed! Manual intervention required."
                return 1
            }

            # =====================================================
            # 主健康检查和部署验证流程
            # =====================================================

            # 检查部署是否成功并进行健康验证
            if [ "$DOCKER_DEPLOY_FAILED" = "true" ]; then
                echo "💥 Skipping health check due to Docker deployment failure."
                echo "🆘 Initiating immediate rollback..."

                if perform_complete_rollback; then
                    echo "✅ Rollback completed successfully."
                    exit 0
                else
                    echo "💥 Rollback failed! Manual intervention required."
                    exit 1
                fi
            else
                # 执行健康检查
                echo "🏥 Health Check Phase:"
                if perform_health_check "$HEALTH_CHECK_URL"; then
                    HEALTH_CHECK_PASSED=true
                    echo "  🎉 Health check passed! Deployment successful."
                else
                    HEALTH_CHECK_PASSED=false
                    echo "  💥 Health check failed! Initiating rollback..."
                fi
            fi

            # =====================================================
            # 部署结果处理和最终状态报告
            # =====================================================

            if [ "$HEALTH_CHECK_PASSED" = "true" ]; then
                # 部署成功流程
                echo ""
                echo "📦 Post-Deployment Backup Phase:"
                echo "  ✓ Creating timestamped backup..."
                if [ -f build.tar.gz ]; then
                    cp build.tar.gz "$VERSION_BACKUP"
                    echo "  ✓ New version backed up as: $VERSION_BACKUP"
                    rm build.tar.gz
                    echo "  ✓ Original build.tar.gz cleaned up."

                    # 清理旧备份文件，只保留最近的两份
                    echo "  🧹 Cleaning up old backup files (keeping latest 2)..."
                    ls -t build-backup-*.tar.gz 2>/dev/null | tail -n +3 | xargs -r rm || true
                    echo "  ✅ Backup cleanup completed."
                else
                    echo "  ⚠️ No build.tar.gz found for backup."
                fi
                echo ""

                echo "🧹 Docker Cleanup Phase:"
                echo "  🗑️ Cleaning up old Docker images..."

                # 删除除了 current 和 previous 之外的所有旧镜像
                docker images "$APP_NAME" --format "{{.Repository}}:{{.Tag}}" | \
                grep -v -E ":current$|:previous$|:backup-" | \
                xargs -r docker rmi 2>/dev/null || true

                # 清理悬空镜像
                docker image prune -f
                echo "  ✅ Image cleanup completed."
                echo ""

                # 成功状态报告
                echo "🎉 === DEPLOYMENT SUCCESSFUL === 🎉"
                echo "Version: $VERSION deployed successfully"
                echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"
                echo "Docker Image: $NEW_IMAGE_TAG"
                echo "Status: All systems operational"
                echo "Health Check: ✅ PASSED"
                echo "Backup Available: ✅ $VERSION_BACKUP"
                echo "Previous Image: ✅ $PREVIOUS_IMAGE_TAG"
                echo "=================================================="
                exit 0

            else
                # 部署失败流程 - 执行回退
                echo ""
                echo "🆘 Deployment failed! Executing rollback strategy..."

                if perform_complete_rollback; then
                    echo ""
                    echo "⚠️ === DEPLOYMENT ROLLED BACK === ⚠️"
                    echo "Version: $VERSION deployment failed"
                    echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"
                    echo "Status: Rollback successful, service restored"
                    echo "Action Taken: Automatic recovery completed"
                    echo "Health Check: ✅ PASSED (after rollback)"
                    echo "=============================================="
                    exit 0
                else
                    echo ""
                    echo "💥 === DEPLOYMENT FAILED === 💥"
                    echo "Version: $VERSION deployment failed"
                    echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"
                    echo "Status: Rollback failed - Manual intervention required"
                    echo "Action Required: Check logs above for details"
                    echo "Health Check: ❌ FAILED"
                    echo "Rollback Status: ❌ FAILED"
                    echo "========================================="
                    exit 1
                fi
            fi
